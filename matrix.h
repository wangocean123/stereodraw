#pragma once

//////////////////////////////
// Installation:
//
// Copy this "matrix.h" file into include directory of your compiler.
//

//////////////////////////////
// Note: This matrix template class defines majority of the matrix
// operations as overloaded operators or methods. It is assumed that
// users of this class is familiar with matrix algebra. We have not
// defined any specialization of this template here, so all the instances
// of matrix will be created implicitly by the compiler. The data types
// tested with this class are float, double, long double, complex<float>,
// complex<double> and complex<long double>. Note that this class is not
// optimized for performance.
//
// Since implementation of exception, namespace and template are still
// not standardized among the various (mainly old) compilers, you may
// encounter compilation error with some compilers. In that case remove
// any of the above three features by defining the following macros:
//
//  _NO_NAMESPACE:  Define this macro to remove namespace support.
//
//  _NO_EXCEPTION:  Define this macro to remove exception handling
//                  and use old style of error handling using function.
//
//  _NO_TEMPLATE:   If this macro is defined matrix class of double
//                  type will be generated by default. You can also
//                  generate a different type of matrix like float.
//
//  _SGI_BROKEN_STL: For SGI C++ v.7.2.1 compiler.
//
//  Since all the definitions are also included in this header file as
//  inline function, some compiler may give warning "inline function
//  can't be expanded". You may ignore/disable this warning using compiler
//  switches. All the operators/methods defined in this class have their
//  natural meaning except the followings:
//
//  Operator/Method                          Description
//  ---------------                          -----------
//   operator ()   :   This function operator can be used as a
//                     two-dimensional subscript operator to get/set
//                     individual matrix elements.
//
//   operator !    :   This operator has been used to calculate inversion
//                     of matrix.
//
//   operator ~    :   This operator has been used to return transpose of
//                     a matrix.
//
//   operator ^    :   It is used calculate power (by a scalar) of a matrix.
//                     When using this operator in a matrix equation, care
//                     must be taken by parenthesizing it because it has
//                     lower precedence than addition, subtraction,
//                     multiplication and division operators.
//
//   operator >>   :   It is used to read matrix from input stream as per
//                     standard C++ stream operators.
//
//   operator <<   :   It is used to write matrix to output stream as per
//                     standard C++ stream operators.
//
// Note that professional version of this package, Matrix TCL Pro 2.0
// is optimized for performance and supports many more matrix operations.
// Matrix TCL Pro 2.0 is available as shareware from our web site at
//

#include "StereoDraw.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

namespace StereoDraw
{

	//////////////////////////////
	// First deal with various shortcomings and incompatibilities of
	// various (mainly old) versions of popular compilers available.
	//


template <class T, int num>
class matrix
{
public:
	static void REPORT_ERROR(const char* msg){}
public:
	// Constructors
	matrix(const matrix<T,num>& m);
	matrix(const T* v=NULL);

	// Destructor
	~matrix();

	// Assignment operators
	matrix<T, num>& operator = (const matrix<T,num>& m);

	// Value extraction method
	size_t RowNo() const {
		return m_Row;
	}
	size_t ColNo() const {
		return m_Col;
	}

	void setData(const T *data);

	// Subscript operator
	T& operator () (size_t row, size_t col);
	T  operator () (size_t row, size_t col) const;

	T* data()const{
		return m_Val;
	}

	// Unary operators
	matrix<T, num> operator + ()  {
		return *this;
	}
	matrix<T, num> operator - ();

	// Combined assignment - calculation operators
	matrix<T, num>& operator += (const matrix<T,num>& m);
	matrix<T, num>& operator -= (const matrix<T,num>& m);
	matrix<T, num>& operator *= (const matrix<T,num>& m);
	matrix<T, num>& operator *= (const T& c);
	matrix<T, num>& operator /= (const T& c);
	matrix<T, num>& operator ^= (const size_t& pow);

	// Miscellaneous -methods
	void Null();
	void Unit();

	// Utility methods
	matrix<T, num> Solve(const matrix<T, num>& v) const;
	matrix<T, num> Adj();
	matrix<T, num> Inv();
	T Det() const;
	T Norm();
	T Cofact(size_t row, size_t col);
	T Cond();

	// Type of matrices
	bool IsSquare()  {
		return (m_Row == m_Col);
	}
	bool IsSingular();
	bool IsDiagonal();
	bool IsScalar();
	bool IsUnit();
	bool IsNull();
	bool IsSymmetric();
	bool IsSkewSymmetric();
	bool IsUpperTriangular();
	bool IsLowerTriangular();

private:
	void Set(size_t row, size_t col, const T* v)
	{
		m_Row = row;
		m_Col = col;

		m_Val = new T[row*col];
		if (v)
			memcpy(m_Val, v, row*col*sizeof(T));
		else
			memset(m_Val, 0, row*col*sizeof(T));
	}
	void Clear()
	{
		delete[] m_Val;
		m_Val = NULL;
		m_Row = m_Col = 0;
	}

	int pivot(size_t row);
	void swapRow(int row1, int row2);

public:
	T *m_Val;
	size_t m_Row, m_Col;
};

// constructor
template <class T,int num> inline
matrix<T,num>::matrix(const T *v)
{
	Set(num,num,v);
	if (v == NULL)
	{
		Unit();
	}
}


// copy constructor
template <class T,int num> inline
matrix<T, num>::matrix(const matrix<T, num>& m)
{
	Set(m.m_Row, m.m_Col, m.m_Val);
}

// destructor
template <class T,int num> inline
matrix<T, num>::~matrix()
{
	Clear();
}

template <class T,int num>
void matrix<T, num>::setData(const T *data)
{
	memcpy(m_Val,data,sizeof(T)*m_Row*m_Col);
}

// assignment operator
template <class T,int num> inline matrix<T, num>&
matrix<T, num>::operator = (const matrix<T, num>& m)
{
	Set(m.m_Row, m.m_Col, m.m_Val);
	return *this;
}


// subscript operator to get/set individual elements
template <class T,int num> inline T&
matrix<T, num>::operator () (size_t row, size_t col)
{
	return m_Val[row*m_Col + col];
}

// subscript operator to get/set individual elements
template <class T,int num> inline T
matrix<T, num>::operator () (size_t row, size_t col) const
{
	if (row >= m_Row || col >= m_Col)
	{
		REPORT_ERROR("matrix<T,num>::operator(): Index out of range!");
		return T();
	}
	return m_Val[row*m_Col + col];

}


// logical equal-to operator
template <class T,int num> inline bool
operator == (const matrix<T, num>& m1, const matrix<T, num>& m2)
{
	if (m1.RowNo() != m2.RowNo() || m1.ColNo() != m2.ColNo())
		return false;

	for (size_t i = 0; i < m1.RowNo(); i++)
		for (size_t j = 0; j < m1.ColNo(); j++)
			if (m1(i, j) != m2(i, j))
				return false;

	return true;

}

// logical no-equal-to operator
template <class T,int num> inline bool
operator != (const matrix<T, num>& m1, const matrix<T, num>& m2)
{

	return (m1 == m2) ? false : true;

}

// combined addition and assignment operator
template <class T,int num> inline matrix<T, num>&
matrix<T, num>::operator += (const matrix<T, num>& m)
{
	if (m_Row != m.m_Row || m_Col != m.m_Col)
	{
		REPORT_ERROR("matrix<T,num>::operator+= : Inconsistent matrix sizes in addition!");
		return *this;
	}
	for (size_t i = 0; i < m.m_Row; i++)
		for (size_t j = 0; j < m.m_Col; j++)
			m_Val[i*m_Col + j] += m.m_Val[i*m_Col + j];
	return *this;

}

// combined subtraction and assignment operator
template <class T,int num> inline matrix<T, num>&
matrix<T, num>::operator -= (const matrix<T, num>& m)
{

	if (m_Row != m.m_Row || m_Col != m.m_Col)
	{
		REPORT_ERROR("matrix<T,num>::operator-= : Inconsistent matrix sizes in subtraction!");
		*this;
	}
	for (size_t i = 0; i < m.m_Row; i++)
		for (size_t j = 0; j < m.m_Col; j++)
			m_Val[i*m_Col + j] -= m.m_Val[i*m_Col + j];
	return *this;

}

// combined scalar multiplication and assignment operator
template <class T,int num> inline matrix<T, num>&
matrix<T, num>::operator *= (const T& c)
{
	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			m_Val[i*m_Col + j] *= c;
	return *this;

}

// combined matrix multiplication and assignment operator
template <class T,int num> inline matrix<T, num>&
matrix<T, num>::operator *= (const matrix<T, num>& m)
{

	if (m_Col != m.m_Row)
	{
		REPORT_ERROR("matrix<T,num>::operator*= : Inconsistent matrix sizes in multiplication!");
		*this;
	}

	matrix<T, num> temp(NULL);

	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m.m_Col; j++)
		{
			temp.m_Val[i*m_Col + j] = T(0);
			for (size_t k = 0; k < m_Col; k++)
				temp.m_Val[i*m_Col + j] += m_Val[i*m_Col + k] * m.m_Val[k*m.m_Col + j];

		}
	*this = temp;

	return *this;

}

// combined scalar division and assignment operator
template <class T,int num> inline matrix<T, num>&
matrix<T, num>::operator /= (const T& c)
{
	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			m_Val[i*m_Col + j] /= c;

	return *this;

}

// combined power and assignment operator
template <class T,int num> inline matrix<T, num>&
matrix<T, num>::operator ^= (const size_t& pow)
{

	matrix<T, num> temp(*this);

	for (size_t i = 2; i <= pow; i++)
		*this = *this * temp;

	return *this;

}

// unary negation operator
template <class T,int num> inline matrix<T, num>
	matrix<T, num>::operator - ()
{
		matrix<T, num> temp(m_Row, m_Col, NULL);

	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			temp.m_Val[i*m_Col + j] = -m_Val[i*m_Col + j];

	return temp;

}

// binary addition operator
template <class T,int num> inline matrix<T, num>
	operator + (const matrix<T, num>& m1, const matrix<T, num>& m2)
{

	matrix<T, num> temp = m1;
	temp += m2;
	return temp;

}

// binary subtraction operator
template <class T,int num> inline matrix<T, num>
	operator - (const matrix<T, num>& m1, const matrix<T, num>& m2)
{

				matrix<T, num> temp = m1;
	temp -= m2;
	return temp;

}

// binary scalar multiplication operator
template <class T,int num> inline matrix<T, num>
	operator * (const matrix<T, num>& m, const T& no)
{

	matrix<T, num> temp = m;
	temp *= no;
	return temp;

}


// binary scalar multiplication operator
template <class T,int num> inline matrix<T, num>
	operator * (const T& no, const matrix<T, num>& m)
{

	return (m * no);

}

// binary matrix multiplication operator
template <class T,int num> inline matrix<T, num>
operator * (const matrix<T, num>& m1, const matrix<T, num>& m2)
{

	matrix<T,num> temp = m1;
	temp *= m2;
	return temp;

}

// binary scalar division operator
template <class T,int num> inline matrix<T,num>
operator / (const matrix<T,num>& m, const T& no)
{

	return (m * (T(1) / no));

}


// binary scalar division operator
template <class T,int num> inline matrix<T,num>
operator / (const T& no, const matrix<T,num>& m)
{

	return (!m * no);

}

// binary matrix division operator
template <class T,int num> inline matrix<T,num>
operator / (const matrix<T,num>& m1, const matrix<T,num>& m2)
{
	return (m1 * !m2);
}

// binary power operator
template <class T,int num> inline matrix<T,num>
operator ^ (const matrix<T,num>& m, const size_t& pow)
{
	matrix<T,num> temp = m;
	temp ^= pow;
	return temp;
}

// unary transpose operator
template <class T,int num> inline matrix<T,num>
operator ~ (const matrix<T,num>& m)
{
	matrix<T,num> temp(m.ColNo(), m.RowNo(), NULL);

	for (size_t i = 0; i < m.RowNo(); i++)
		for (size_t j = 0; j < m.ColNo(); j++)
		{
			T x = m(i, j);
			temp(j, i) = x;
		}
	return temp;

}

// unary inversion operator
template <class T,int num> inline matrix<T,num>
operator ! (const matrix<T,num> m)
{
	matrix<T,num> temp = m;
	return temp.Inv();
}

template <class T,int num> 
void matrix<T,num>::swapRow(int row1, int row2)
{
	if (row1 == row2)
		return;

	T* pv = new T[m_Col];
	memcpy(pv, m_Val + row1*m_Col, sizeof(T)*m_Col);
	memcpy(m_Val + row1*m_Col, m_Val + row2*m_Col, sizeof(T)*m_Col);
	memcpy(m_Val + row2*m_Col, pv, sizeof(T)*m_Col);
	delete[] pv;
}

// inversion function
template <class T,int num> inline matrix<T,num>
matrix<T,num>::Inv()
{
	size_t i, j, k;
	T a1, a2;

	if (m_Row != m_Col)
	{
		REPORT_ERROR("matrix<T,num>::operator!: Inversion of a non-square matrix");
		*this;
	}

	matrix<T,num> temp(NULL);

	temp.Unit();
	for (k = 0; k < m_Row; k++)
	{
		int indx = pivot(k);
		if (indx == -1)
		{
			REPORT_ERROR("matrix<T,num>::operator!: Inversion of a singular matrix");
			*this;
		}

		if (indx != 0)
		{
			swapRow(k, indx);
		}
		a1 = m_Val[k*m_Col + k];
		for (j = 0; j < m_Row; j++)
		{
			m_Val[k*m_Col + j] /= a1;
			temp.m_Val[k*m_Col + j] /= a1;
		}
		for (i = 0; i < m_Row; i++)
		{
			if (i != k)
			{
				a2 = m_Val[i*m_Col + k];
				for (j = 0; j < m_Row; j++)
				{

					m_Val[i*m_Col + j] -= a2 * m_Val[k*m_Col + j];
					temp.m_Val[i*m_Col + j] -= a2 * temp.m_Val[k*m_Col + j];
				}
			}
		}
	}
	return temp;

}

// solve simultaneous equation
template <class T,int num> inline matrix<T,num>
matrix<T,num>::Solve(const matrix<T,num>& v) const
{

	size_t i, j, k;
	T a1;

	if (!(m_Row == m_Col && m_Col == v.m_Row))
	{
		REPORT_ERROR("matrix<T,num>::Solve():Inconsistent matrices!");
		*this;
	}

	matrix<T,num> temp(NULL);
	for (i = 0; i < m_Row; i++)
	{
		for (j = 0; j < m_Col; j++)
			temp.m_Val[i*m_Col + j] = m_Val[i*m_Col + j];
		for (k = 0; k < v.m_Col; k++)
			temp.m_Val[i*m_Col + m_Col + k] = v.m_Val[i*m_Col + k];

	}
	for (k = 0; k < m_Row; k++)
	{
		int indx = temp.pivot(k);
		if (indx == -1)
		{
			REPORT_ERROR("matrix<T,num>::Solve(): Singular matrix!");
			*this;
		}

		a1 = temp.m_Val[k*m_Col + k];
		for (j = k; j < temp.m_Col; j++)
			temp.m_Val[k*m_Col + j] /= a1;

		for (i = k + 1; i < m_Row; i++)
		{

			a1 = temp.m_Val[i*m_Col + k];
			for (j = k; j < temp.m_Col; j++)
				temp.m_Val[i*m_Col + j] -= a1 * temp.m_Val[k*m_Col + j];

		}

	}
	matrix<T,num> s(NULL);
	for (k = 0; k < v.m_Col; k++)
		for (int m = int(m_Row) - 1; m >= 0; m--)
		{

			s.m_Val[m*m_Col + k] = temp.m_Val[m*m_Col + m_Col + k];
			for (j = m + 1; j < m_Col; j++)
				s.m_Val[m*m_Col + k] -= temp.m_Val[m*m_Col + j] * s.m_Val[j*m_Col + k];

		}
	return s;

}


// set zero to all elements of this matrix
template <class T,int num> inline void
matrix<T,num>::Null()
{
	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			m_Val[i*m_Col + j] = T(0);
	return;

}


// set this matrix to unity
template <class T,int num> inline void
matrix<T,num>::Unit()
{
	if (m_Row != m_Col)
	{
		REPORT_ERROR("matrix<T,num>::Unit(): This is a non-square matrix!");
		return;
	}

	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			m_Val[i*m_Col + j] = i == j ? T(1) : T(0);
	return;

}

// private partial pivoting method
template <class T,int num> inline int
matrix<T,num>::pivot(size_t row)
{
	int k = int(row);
	double amax, temp;

	amax = -1;
	for (size_t i = row; i < m_Row; i++)
		if ((temp = fabs(m_Val[i*m_Col + row])) > amax && temp != 0.0)
		{
			amax = temp;
			k = i;
		}
	if (m_Val[k*m_Col + row] == T(0))
		return -1;
	if (k != int(row))
	{
		swapRow(k, row);
		return k;

	}
	return 0;

}

// calculate the determinant of a matrix
template <class T,int num> inline T
matrix<T,num>::Det() const
{
	size_t i, j, k;
	T piv, detVal = T(1);

	if (m_Row != m_Col)
	{
		REPORT_ERROR("matrix<T,num>::Det(): Determinant a non-square matrix!");
		return T();
	}

	matrix<T,num> temp(*this);

	for (k = 0; k < m_Row; k++)
	{
		int indx = temp.pivot(k);
		if (indx == -1)
			return 0;
		if (indx != 0)
			detVal = -detVal;
		detVal = detVal * temp.m_Val[k*m_Col + k];
		for (i = k + 1; i < m_Row; i++)
		{

			piv = temp.m_Val[i*m_Col + k] / temp.m_Val[k*m_Col + k];
			for (j = k + 1; j < m_Row; j++)
				temp.m_Val[i*m_Col + j] -= piv * temp.m_Val[k*m_Col + j];

		}

	}
	return detVal;

}

// calculate the norm of a matrix
template <class T,int num> inline T
matrix<T,num>::Norm()
{

	T retVal = T(0);

	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			retVal += m_Val[i*m_Col + j] * m_Val[i*m_Col + j];
	retVal = sqrt(retVal);

	return retVal;

}

// calculate the condition number of a matrix
template <class T,int num> inline T
matrix<T,num>::Cond()
{

	matrix<T,num> inv = !(*this);
	return (Norm() * inv.Norm());

}

// calculate the cofactor of a matrix for a given element
template <class T,int num> inline T
matrix<T,num>::Cofact(size_t row, size_t col)
{

	size_t i, i1, j, j1;

	if (m_Row != m_Col)
	{
		REPORT_ERROR("matrix<T,num>::Cofact(): Cofactor of a non-square matrix!");
		return T();
	}

	if (row > m_Row || col > m_Col)
	{
		REPORT_ERROR("matrix<T,num>::Cofact(): Index out of range!");
		return T();
	}

	matrix<T,num> temp(NULL);

	for (i = i1 = 0; i < m_Row; i++)
	{

		if (i == row)
			continue;
		for (j = j1 = 0; j < m_Col; j++)
		{

			if (j == col)
				continue;
			temp.m_Val[i1*m_Col + j1] = m_Val[i*m_Col + j];
			j1++;

		}
		i1++;

	}
	T  cof = temp.Det();
	if ((row + col) % 2 == 1)
		cof = -cof;

	return cof;

}


// calculate adjoin of a matrix
template <class T,int num> inline matrix<T,num>
matrix<T,num>::Adj()
{
	if (m_Row != m_Col)
	{
		REPORT_ERROR("matrix<T,num>::Adj(): Adjoin of a non-square matrix.");
		return *this;
	}

	matrix<T,num> temp(NULL);

	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			temp.m_Val[j*m_Col + i] = Cofact(i, j);
	return temp;

}

// Determine if the matrix is singular
template <class T,int num> inline bool
matrix<T,num>::IsSingular()
{
	if (m_Row != m_Col)
		return false;
	return (Det() == T(0));

}

// Determine if the matrix is diagonal
template <class T,int num> inline bool
matrix<T,num>::IsDiagonal()
{
	if (m_Row != m_Col)
		return false;
	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			if (i != j && m_Val[i*m_Col + j] != T(0))
				return false;
	return true;

}

// Determine if the matrix is scalar
template <class T,int num> inline bool
matrix<T,num>::IsScalar()
{
	if (!IsDiagonal())
		return false;
	T v = m_Val[0];
	for (size_t i = 1; i < m_Row; i++)
		if (m_Val[i*m_Col + i] != v)
			return false;
	return true;

}

// Determine if the matrix is a unit matrix
template <class T,int num> inline bool
matrix<T,num>::IsUnit()
{
	if (IsScalar() && m_Val[0] == T(1))
		return true;
	return false;

}

// Determine if this is a null matrix
template <class T,int num> inline bool
matrix<T,num>::IsNull()
{
	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			if (m_Val[i*m_Col + j] != T(0))
				return false;
	return true;

}

// Determine if the matrix is symmetric
template <class T,int num> inline bool
matrix<T,num>::IsSymmetric()
{
	if (m_Row != m_Col)
		return false;
	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			if (m_Val[i*m_Col + j] != m_Val[j*m_Col + i])
				return false;
	return true;

}

// Determine if the matrix is skew-symmetric
template <class T,int num> inline bool
matrix<T,num>::IsSkewSymmetric()
{
	if (m_Row != m_Col)
		return false;
	for (size_t i = 0; i < m_Row; i++)
		for (size_t j = 0; j < m_Col; j++)
			if (m_Val[i*m_Col + j] != -m_Val[j*m_Col + i])
				return false;
	return true;

}

// Determine if the matrix is upper triangular
template <class T,int num> inline bool
matrix<T,num>::IsUpperTriangular()
{
	if (m_Row != m_Col)
		return false;
	for (size_t i = 1; i < m_Row; i++)
		for (size_t j = 0; j < i - 1; j++)
			if (m_Val[i*m_Col + j] != T(0))
				return false;
	return true;

}

// Determine if the matrix is lower triangular
template <class T,int num> inline bool
matrix<T,num>::IsLowerTriangular()
{
	if (m_Row != m_Col)
		return false;

	for (size_t j = 1; j < m_Col; j++)
		for (size_t i = 0; i < j - 1; i++)
			if (m_Val[i*m_Col + j] != T(0))
				return false;

	return true;
}


typedef matrix<double, 3> matrix3d;
typedef matrix<double, 4> matrix4d;

matrix3d STEREODRAW_API matrix3d_move(double dx, double dy);
matrix3d STEREODRAW_API matrix3d_rotate(const point_2d *pt, double angle);
matrix3d STEREODRAW_API matrix3d_zoom(double zoom_x, double zoom_y);

matrix4d STEREODRAW_API matrix4d_move(double dx, double dy, double dz);
matrix4d STEREODRAW_API matrix4d_rotate(const point_3d *pt, const point_3d *dpt, double angle);
matrix4d STEREODRAW_API matrix4d_zoom(double zoom_x, double zoom_y, double zoom_z);
bool STEREODRAW_API matrix4d_is_zrotate(const matrix4d& m);

template<class point_type>
void transform_pts_by_matrix_2d(point_type *pts, int npt, const matrix3d& m)
{
	for (int i = 0; i < npt; i++)
	{
		point_type pt = pts[i];
		double x = pt.x * m(0, 0) + pt.y * m(0, 1) + m(0, 2);
		double y = pt.x * m(1, 0) + pt.y * m(1, 1) + m(1, 2);
		pt.x = x, pt.y = y;
		pts[i] = pt;
	}
}


template<class point_type>
void transform_pts_by_matrix_2d(point_type *pts, int npt, const matrix4d& m)
{
	for (int i = 0; i < npt; i++)
	{
		point_type pt = pts[i];
		double x = pt.x * m(0, 0) + pt.y * m(0, 1) + m(0, 3);
		double y = pt.x * m(1, 0) + pt.y * m(1, 1) + m(1, 3);
		pt.x = x, pt.y = y;
		pts[i] = pt;
	}
}

template<class point_type>
void transform_pts_by_matrix_3d(point_type *pts, int npt, const matrix4d& m)
{
	for (int i = 0; i < npt; i++)
	{
		point_type pt = pts[i];
		double x = pt.x * m(0, 0) + pt.y * m(0, 1) + pt.z * m(0, 2) + m(0, 3);
		double y = pt.x * m(1, 0) + pt.y * m(1, 1) + pt.z * m(1, 2) + m(1, 3);
		double z = pt.x * m(2, 0) + pt.y * m(2, 1) + pt.z * m(2, 2) + m(2, 3);
		pt.x = x, pt.y = y, pt.z = z;
		pts[i] = pt;
	}
}

}